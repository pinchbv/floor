import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:coverage/coverage.dart' as coverage;
import 'package:path/path.dart' as path;

final _sep = path.separator;

List<File> findTestFiles(Directory packageRoot) {
  final testsPath = path.join(packageRoot.absolute.path, 'test');
  final testsRoot = Directory(testsPath);
  final contents = testsRoot.listSync(recursive: true);
  final result = <File>[];
  for (final item in contents) {
    if (item is! File) continue;
    if (!item.path.endsWith('_test.dart')) continue;
    result.add(item);
  }
  return result;
}

class TestFileInfo {
  final File testFile;
  final String alias;
  final String import;

  TestFileInfo._(this.testFile, this.alias, this.import);

  factory TestFileInfo.forFile(File testFile) {
    final parts = testFile.absolute.path.split(_sep).toList();
    var relative = <String>[];
    while (parts.last != 'test') {
      relative.add(parts.last);
      parts.removeLast();
    }
    relative = relative.reversed.toList();
    final alias = relative.join('_').replaceFirst('.dart', '');
    final importPath = relative.join(_sep);
    final import = "import '$importPath' as $alias;";
    return TestFileInfo._(testFile, alias, import);
  }
}

void generateMainScript(Directory packageRoot, List<File> testFiles) {
  final imports = <String>[];
  final mainBody = <String>[];

  for (final test in testFiles) {
    final info = TestFileInfo.forFile(test);
    imports.add(info.import);
    mainBody.add('  ${info.alias}.main();');
  }
  imports.sort();
  mainBody.sort((a, b) => a[3].compareTo(b[3]));

  final buffer = StringBuffer()
    ..writeln('// Auto-generated by test_coverage. Do not edit by hand.')
    ..writeln();
  imports.forEach(buffer.writeln);
  buffer..writeln()..writeln('void main() {');
  mainBody.forEach(buffer.writeln);
  buffer.writeln('}');

  File(path.join(packageRoot.path, 'test', '.test_coverage.dart'))
      .writeAsStringSync(buffer.toString());
}

Future<void> runTestsAndCollect(String packageRoot) async {
  final script = path.join(packageRoot, 'test', '.test_coverage.dart');
  final dartArgs = [
    '--pause-isolates-on-exit',
    '--enable-vm-service',
    '--no-sound-null-safety',
    script,
  ];

  final process = await Process.start('dart', dartArgs);
  final serviceUriCompleter = Completer<Uri>();
  process.stdout
      .transform(utf8.decoder)
      .transform(const LineSplitter())
      .listen((line) {
    print(line);
    final uri = _extractObservatoryUri(line);
    if (uri != null) serviceUriCompleter.complete(uri);
  });

  final serviceUri = await serviceUriCompleter.future;
  Map<String, Map<int, int>> hitmap;
  try {
    final data = await coverage.collect(serviceUri, true, true, false, {});
    hitmap = coverage.createHitmap(data['coverage']);
  } finally {
    await process.stderr.drain<List<int>>();
  }
  final exitStatus = await process.exitCode;
  if (exitStatus != 0) throw 'Tests failed with exit code $exitStatus';

  final resolver = coverage.Resolver(
    packagesPath: path.join(packageRoot, '.packages'),
  );
  final lcov = coverage.LcovFormatter(
    resolver,
    reportOn: ['lib${path.separator}'],
    basePath: packageRoot,
  );
  final coverageData = await lcov.format(hitmap);
  final coveragePath = path.join(packageRoot, 'coverage');
  final coverageDir = Directory(coveragePath);
  if (!coverageDir.existsSync()) coverageDir.createSync();
  final coverageFile = File(path.join(coveragePath, 'lcov.info'));
  coverageFile.writeAsStringSync(coverageData);
  print('Coverage report saved to "coverage/lcov.info".');
}

// copied from `coverage` package
Uri _extractObservatoryUri(String str) {
  const kObservatoryListening = 'Observatory listening on ';
  final int msgPos = str.indexOf(kObservatoryListening);
  if (msgPos == -1) return null;
  final int startPos = msgPos + kObservatoryListening.length;
  final int endPos = str.indexOf(RegExp(r'(\s|$)'), startPos);
  try {
    return Uri.parse(str.substring(startPos, endPos));
  } on FormatException {
    return null;
  }
}
